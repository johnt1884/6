<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortcuts</title>
     <style>
        :root {
            --bg-color: #EBEBEB;
            --toolbar-color: #1877f2;
            --root-sc-color: green;
            --subfolder-sc-color: yellow;
            --both-sc-color: blue;
            --header-text-color: #1c1e21;
            --row-number-color: #333333;
            --date-text-color: #555555;
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .top-bar {
            padding: 10px;
            border-bottom: 1px solid #444444;
            display: flex;
            align-items: center;
            height: 36px;
            box-sizing: border-box;
            background-color: var(--toolbar-color);
        }
        .bottom-bar {
            padding: 10px;
            border-top: 1px solid #444444;
            display: flex;
            align-items: center;
            height: 36px;
            box-sizing: border-box;
            background-color: var(--toolbar-color);
            color: white;
            justify-content: space-between;
        }
        #thumbnail-container {
            flex-grow: 1;
            padding: 20px;
            position: relative;
            overflow: auto;
            min-width: 0;
        }
        .thumbnail {
            object-fit: cover;
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            cursor: pointer;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 2500;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 24px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 680px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .close {
            color: #606770;
            float: right;
            font-size: 32px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: #1c1e21;
            text-decoration: none;
            cursor: pointer;
        }
        #batch-script {
            width: 100%;
            box-sizing: border-box;
            border-radius: 6px;
            border: 1px solid #ccd0d5;
            padding: 8px;
            font-family: "Courier New", Courier, monospace;
            margin-top: 8px;
            margin-bottom: 12px;
            resize: vertical;
        }
        .landscape-row {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        .thumbnail.selected-root-sc {
            outline: 3px dashed var(--root-sc-color);
        }
        .thumbnail.selected-subfolder-sc {
            outline: 3px dashed var(--subfolder-sc-color);
        }
        .thumbnail.selected-both-sc {
            outline: 3px dashed var(--both-sc-color);
        }
        .thumbnail.selected-shortcut {
            outline: 3px dashed green;
        }
        select {
            height: 36px;
            padding: 0 8px 0 8px;
            padding-right: 32px;
            border: 1px solid #444444;
            background-color: var(--toolbar-color);
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 10px;
            text-align: center;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
        }
        select option {
            padding: 8px 12px;
            background-color: #ffffff;
            color: #000000;
        }
        .bar-button {
            height: 36px;
            padding: 0 12px;
            border: 1px solid #444444;
            background-color: var(--toolbar-color);
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            cursor: pointer;
        }
        .bar-button:hover {
            background-color: #166fe5;
        }
        .selection-type-button.active {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: #ffffff;
        }
        #root-sc-btn.active {
            outline: 3px dashed var(--root-sc-color);
            outline-offset: -3px;
        }
        #subfolder-sc-btn.active {
            outline: 3px dashed var(--subfolder-sc-color);
            outline-offset: -3px;
        }
        #both-sc-btn.active {
            outline: 3px dashed var(--both-sc-color);
            outline-offset: -3px;
        }
        .project-header {
            color: var(--header-text-color);
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .date-info {
            display: none;
            font-size: 0.8em;
            font-weight: normal;
            color: var(--date-text-color);
        }
        .main-container.show-dates .date-info {
            display: inline;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-left: 15px;
            color: white;
            font-size: 14px;
        }
        .checkbox-container input {
            margin-right: 5px;
        }
        .row-number {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--row-number-color);
            margin-right: 10px;
            align-self: center;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #ffffff;
            min-width: 450px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 3000;
            top: 100%;
            left: 0;
            border: 1px solid #ccc;
        }
        .dropdown-content button {
            color: black;
            padding: 10px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            border: none;
            background-color: #ffffff;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }
        .dropdown-content button:nth-child(even) {
            background-color: #f2f2f2;
        }
        .dropdown-content button:hover {
            background-color: #e2e2e2;
        }
        .dropdown-content .show {
            display: block;
        }
        .options-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            color: black;
            font-size: 14px;
        }
        .options-row:nth-child(even) {
            background-color: #f2f2f2;
        }
        .options-row label {
            cursor: pointer;
        }
        .options-row input[type="color"] {
            border: none;
            width: 30px;
            height: 30px;
            cursor: pointer;
            background: none;
        }
        .selection-type-button {
            display: flex;
            align-items: center;
        }
        .color-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="main-content">
            <div class="top-bar">
                <div id="load-menu-container" style="position: relative; margin-right: 10px;">
                    <button id="load-menu-btn" title="Load" class="bar-button" style="padding: 0 8px; display: flex; align-items: center; justify-content: center;">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: white;"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>
                    </button>
                    <div id="load-dropdown" class="dropdown-content">
                        <button id="load-directory-btn">Load all videos</button>
                        <button id="load-latest-videos-btn">Load new videos</button>
                        <button id="load-sc-btn">Load all shortcuts</button>
                        <button id="load-sc-new-btn">Load new shortcuts</button>
                        <button id="load-root-sc-btn">Load root shortcut directory</button>
                        <button id="create-playlist-load-btn">Create playlist</button>
                    </div>
                </div>
                <div id="options-menu-container" style="position: relative; margin-right: 10px;">
                    <button id="options-menu-btn" title="Options" class="bar-button" style="padding: 0 8px; display: flex; align-items: center; justify-content: center;">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: white;">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <div id="options-dropdown" class="dropdown-content">
                        <div class="options-row">
                            <label for="bg-color-picker">Page Background</label>
                            <input type="color" id="bg-color-picker" value="#EBEBEB">
                        </div>
                        <div class="options-row">
                            <label for="toolbar-color-picker">Toolbars</label>
                            <input type="color" id="toolbar-color-picker" value="#1877f2">
                        </div>
                        <div class="options-row">
                            <label for="root-sc-color-picker">Root SC Outline</label>
                            <input type="color" id="root-sc-color-picker" value="#008000">
                        </div>
                        <div class="options-row">
                            <label for="subfolder-sc-color-picker">Subfolder SC Outline</label>
                            <input type="color" id="subfolder-sc-color-picker" value="#ffff00">
                        </div>
                        <div class="options-row">
                            <label for="both-sc-color-picker">Both SC Outline</label>
                            <input type="color" id="both-sc-color-picker" value="#0000ff">
                        </div>
                        <div class="options-row">
                            <label for="header-text-color-picker">Folder Header Color</label>
                            <input type="color" id="header-text-color-picker" value="#1c1e21">
                        </div>
                        <div class="options-row">
                            <label for="row-number-color-picker">Row Numbers Color</label>
                            <input type="color" id="row-number-color-picker" value="#333333">
                        </div>
                        <div class="options-row">
                            <label for="date-text-color-picker">Date Text Color</label>
                            <input type="color" id="date-text-color-picker" value="#555555">
                        </div>
                        <button id="revert-defaults-btn" style="width: 100%; text-align: center; border-top: 1px solid #ccc; font-weight: bold;">Revert to Default Colors</button>
                    </div>
                </div>
                <select id="size-selector">
                    <option value="0.2">20%</option>
                    <option value="0.3">30%</option>
                    <option value="0.4">40%</option>
                    <option value="0.5">50%</option>
                    <option value="0.6">60%</option>
                    <option value="0.7">70%</option>
                    <option value="0.8">80%</option>
                    <option value="0.9">90%</option>
                    <option value="1" selected>100%</option>
                </select>
                <select id="sort-selector">
                    <option value="" disabled selected hidden>Sort</option>
                    <option value="name-asc">Name (A-Z)</option>
                    <option value="name-desc">Name (Z-A)</option>
                    <option value="date-new">Date (Newest)</option>
                    <option value="date-old">Date (Oldest)</option>
                </select>
                <button id="prev-canvas-btn" class="bar-button">&lt;</button>
                <select id="canvas-select"></select>
                <button id="next-canvas-btn" class="bar-button">&gt;</button>
                <select id="group-selector"></select>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-dates-checkbox">
                    <label for="show-dates-checkbox">Show Dates</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-old-thumbs-checkbox">
                    <label for="show-old-thumbs-checkbox">Show Old</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-numbers-checkbox">
                    <label for="show-numbers-checkbox">Show Numbers</label>
                </div>
            </div>
            <div id="content-area" style="display: flex; flex-grow: 1; overflow: hidden;">
                <div id="thumbnail-container">
                    <div class="landscape-row" data-video-name="video1" data-project-path="ProjectA">
                        <img class="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-width="256" data-original-height="144" style="width: 256px; height: 144px; margin-right: 10px; margin-bottom: 10px;">
                    </div>
                    <div id="content-spacer" style="position: absolute; top: 0; left: 0; z-index: -1;"></div>
                </div>
            </div>
            <div class="bottom-bar">
                <div>
                    <button id="root-sc-btn" class="bar-button selection-type-button" style="display: none;"><span class="color-circle"></span>Root SC</button>
                    <button id="subfolder-sc-btn" class="bar-button selection-type-button" style="display: none;"><span class="color-circle"></span>Subfolder SC</button>
                    <button id="both-sc-btn" class="bar-button selection-type-button" style="display: none;"><span class="color-circle"></span>Both</button>
                </div>
                <div>
                    <button id="shortcut-script-btn" class="bar-button">Create Shortcut Script</button>
                    <button id="create-playlist-btn" class="bar-button" style="display: none;">Create Playlist</button>
                    <button id="delete-shortcuts-btn" class="bar-button" style="display: none;">Delete Selected Shortcuts</button>
                    <button id="x-shortcut-btn" class="bar-button" style="display: none;">X Shortcut</button>
                </div>
            </div>
        </div>
    </div>

    <div id="script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Create Shortcut PowerShell Script</h2>
            <p>This script will create shortcuts for your selections. Right-click and "Run with PowerShell" in your main video directory.</p>
            <textarea id="batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-script-btn">Copy to Clipboard</button>
            <a id="download-script-link" download="create_shortcuts.ps1">
                <button>Download .ps1 File</button>
            </a>
        </div>
    </div>

    <script>
        const thumbnailContainer = document.getElementById('thumbnail-container');
        const scriptModal = document.getElementById('script-modal');
        const batchScriptTextArea = document.getElementById('batch-script');
        const copyScriptBtn = document.getElementById('copy-script-btn');
        const downloadScriptLink = document.getElementById('download-script-link');
        const sizeSelector = document.getElementById('size-selector');
        const sortSelector = document.getElementById('sort-selector');
        const loadButton = document.getElementById('load-directory-btn');
        const loadScButton = document.getElementById('load-sc-btn');
        const loadScNewButton = document.getElementById('load-sc-new-btn');
        const loadLatestVideosButton = document.getElementById('load-latest-videos-btn');
        const loadRootScButton = document.getElementById('load-root-sc-btn');
        const createPlaylistLoadBtn = document.getElementById('create-playlist-load-btn');
        const shortcutScriptBtn = document.getElementById('shortcut-script-btn');
        const createPlaylistBtn = document.getElementById('create-playlist-btn');
        const deleteShortcutsBtn = document.getElementById('delete-shortcuts-btn');
        const xShortcutBtn = document.getElementById('x-shortcut-btn');
        const contentSpacer = document.getElementById('content-spacer');
        const canvasSelect = document.getElementById('canvas-select');
        const groupSelector = document.getElementById('group-selector');
        const rootScBtn = document.getElementById('root-sc-btn');
        const subfolderScBtn = document.getElementById('subfolder-sc-btn');
        const bothScBtn = document.getElementById('both-sc-btn');
        const prevCanvasBtn = document.getElementById('prev-canvas-btn');
        const nextCanvasBtn = document.getElementById('next-canvas-btn');
        const loadMenuBtn = document.getElementById('load-menu-btn');
        const loadDropdown = document.getElementById('load-dropdown');
        const optionsMenuBtn = document.getElementById('options-menu-btn');
        const optionsDropdown = document.getElementById('options-dropdown');
        const revertDefaultsBtn = document.getElementById('revert-defaults-btn');

        let allVideoFiles = [];
        let allProjectFolders = [];
        let shortcutSelections = new Map(); // Key: projectPath + '|' + videoName, Value: { videoName, projectPath, subfolder, type }
        let currentDirHandle;
        let g_rootHandle;
        let currentMode = '';
        let canvases = new Map();
        let activeCanvasId = 0;
        let createdObjectUrls = [];
        let dummyTimestampProjects = new Set();
        let currentSelectionType = 'root-sc';
        const mainContainer = document.querySelector('.main-container');
        const showDatesCheckbox = document.getElementById('show-dates-checkbox');
        const showOldThumbsCheckbox = document.getElementById('show-old-thumbs-checkbox');
        const showNumbersCheckbox = document.getElementById('show-numbers-checkbox');

        function updateRowNumbers() {
            const showNumbers = showNumbersCheckbox.checked;
            const rows = document.querySelectorAll('.landscape-row');
            
            // First, remove any existing numbers to avoid duplicates
            document.querySelectorAll('.row-number').forEach(num => num.remove());

            if (showNumbers) {
                rows.forEach((row, index) => {
                    const numberSpan = document.createElement('span');
                    numberSpan.className = 'row-number';
                    numberSpan.textContent = index + 1;
                    row.insertBefore(numberSpan, row.firstChild);
                });
            }
        }

        function init() {
            loadMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                optionsDropdown.style.display = 'none';
                loadDropdown.style.display = loadDropdown.style.display === 'block' ? 'none' : 'block';
            });

            optionsMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                loadDropdown.style.display = 'none';
                optionsDropdown.style.display = optionsDropdown.style.display === 'block' ? 'none' : 'block';
            });

            window.addEventListener('click', () => {
                loadDropdown.style.display = 'none';
                optionsDropdown.style.display = 'none';
            });

            optionsDropdown.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            const colorPickers = {
                'bg-color': document.getElementById('bg-color-picker'),
                'toolbar-color': document.getElementById('toolbar-color-picker'),
                'root-sc-color': document.getElementById('root-sc-color-picker'),
                'subfolder-sc-color': document.getElementById('subfolder-sc-color-picker'),
                'both-sc-color': document.getElementById('both-sc-color-picker'),
                'header-text-color': document.getElementById('header-text-color-picker'),
                'row-number-color': document.getElementById('row-number-color-picker'),
                'date-text-color': document.getElementById('date-text-color-picker')
            };

            // Load saved colors
            Object.keys(colorPickers).forEach(id => {
                const saved = localStorage.getItem(`sc-color-${id}`);
                if (saved) {
                    document.documentElement.style.setProperty(`--${id}`, saved);
                    colorPickers[id].value = saved;
                }
            });

            // Handle color changes
            Object.keys(colorPickers).forEach(id => {
                colorPickers[id].addEventListener('input', (e) => {
                    const color = e.target.value;
                    document.documentElement.style.setProperty(`--${id}`, color);
                    localStorage.setItem(`sc-color-${id}`, color);
                    if (id.includes('sc-color')) {
                        updateCircleColors();
                    }
                });
            });

            revertDefaultsBtn.addEventListener('click', () => {
                const defaults = {
                    'bg-color': '#EBEBEB',
                    'toolbar-color': '#1877f2',
                    'root-sc-color': '#008000',
                    'subfolder-sc-color': '#ffff00',
                    'both-sc-color': '#0000ff',
                    'header-text-color': '#1c1e21',
                    'row-number-color': '#333333',
                    'date-text-color': '#555555'
                };
                Object.keys(defaults).forEach(id => {
                    const color = defaults[id];
                    document.documentElement.style.setProperty(`--${id}`, color);
                    colorPickers[id].value = color;
                    localStorage.removeItem(`sc-color-${id}`);
                });
                updateCircleColors();
            });

            updateCircleColors();

            loadButton.addEventListener('click', async () => {
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    currentDirHandle = dirHandle;
                    currentMode = 'directory';
                    setVisibilityForMode(currentMode);
                    await renderDirectoryMode();
                } catch (err) {
                    if (err.name !== 'AbortError') console.error('Failed to open directory:', err);
                }
            });

            loadScButton.addEventListener('click', async () => {
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    currentDirHandle = dirHandle;
                    currentMode = 'sc';
                    setVisibilityForMode(currentMode);
                    await renderScMode();
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Failed to open directory or render SC mode:', err);
                    }
                }
            });

            loadScNewButton.addEventListener('click', async () => {
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    currentDirHandle = dirHandle;
                    currentMode = 'sc-new';
                    setVisibilityForMode(currentMode);
                    await renderScNewMode();
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Failed to open directory or render SC New mode:', err);
                    }
                }
            });

            loadLatestVideosButton.addEventListener('click', async () => {
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    currentDirHandle = dirHandle;
                    currentMode = 'latest-videos';
                    setVisibilityForMode(currentMode);
                    await renderLatestVideosMode();
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Failed to open directory or render latest videos mode:', err);
                    }
                }
            });

            scriptModal.querySelector('.close').addEventListener('click', () => scriptModal.style.display = 'none');
            
            copyScriptBtn.addEventListener('click', () => {
                 batchScriptTextArea.select();
                 navigator.clipboard.writeText(batchScriptTextArea.value).then(() => {
                    alert('Script copied to clipboard!');
                });
            });

            shortcutScriptBtn.addEventListener('click', () => {
                if (shortcutSelections.size === 0 && dummyTimestampProjects.size === 0) {
                    alert('Please select one or more thumbnails or activate a dummy timestamp before creating a script.');
                    return;
                }
                generateShortcutScript();
                scriptModal.style.display = 'block';
            });

            xShortcutBtn.addEventListener('click', () => {
                if (shortcutSelections.size === 0) {
                    alert('Please select one or more thumbnails to create shortcuts for.');
                    return;
                }
                generateXShortcutScript();
                scriptModal.style.display = 'block';
            });

            sizeSelector.addEventListener('change', () => layoutLandscapeThumbnails());
            
            sortSelector.addEventListener('change', (e) => {
                if(currentDirHandle) {
                    if (currentMode === 'directory') {
                        renderDirectoryMode(e.target.value);
                    } else if (currentMode === 'latest-videos') {
                        renderLatestVideosMode(e.target.value);
                    } else if (currentMode === 'sc') {
                        renderScGroup(parseInt(groupSelector.value, 10), e.target.value);
                    }
                }
            });

            groupSelector.addEventListener('change', async (e) => {
                const groupIndex = parseInt(e.target.value, 10);
                await renderScGroup(groupIndex, sortSelector.value);
            });

            loadRootScButton.addEventListener('click', async () => {
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    currentDirHandle = dirHandle;
                    currentMode = 'root-sc';
                    setVisibilityForMode(currentMode);
                    await renderRootScMode();
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Failed to open directory or render Root SC mode:', err);
                    }
                }
            });

            createPlaylistLoadBtn.addEventListener('click', async () => {
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    currentDirHandle = dirHandle;
                    currentMode = 'playlist';
                    setVisibilityForMode(currentMode);
                    await renderPlaylistMode();
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Failed to open directory or render playlist mode:', err);
                    }
                }
            });

            createPlaylistBtn.addEventListener('click', () => {
                if (shortcutSelections.size === 0) {
                    alert('Please select one or more directories to include in the playlist.');
                    return;
                }
                generatePlaylistScript();
                scriptModal.style.display = 'block';
            });

            deleteShortcutsBtn.addEventListener('click', () => {
                if (shortcutSelections.size === 0) {
                    alert('Please select one or more shortcuts to delete.');
                    return;
                }
                generateDeleteScript();
                scriptModal.style.display = 'block';
            });

            rootScBtn.addEventListener('click', () => setSelectionType('root-sc'));
            subfolderScBtn.addEventListener('click', () => setSelectionType('subfolder-sc'));
            bothScBtn.addEventListener('click', () => setSelectionType('both-sc'));

            prevCanvasBtn.addEventListener('click', () => navigateCanvas(-1));
            nextCanvasBtn.addEventListener('click', () => navigateCanvas(1));
        }

        function navigateCanvas(direction) {
            const canvasIds = Array.from(canvases.keys());
            if (canvasIds.length <= 1) return;

            const currentIndex = canvasIds.indexOf(activeCanvasId);
            let nextIndex = currentIndex + direction;

            if (nextIndex < 0) {
                nextIndex = canvasIds.length - 1;
            } else if (nextIndex >= canvasIds.length) {
                nextIndex = 0;
            }

            const nextCanvasId = canvasIds[nextIndex];
            renderCanvas(nextCanvasId);
        }

        function setSelectionType(type) {
            currentSelectionType = type;
            updateSelectionTypeButtons();
        }

        function updateCircleColors() {
            const rootCircle = rootScBtn.querySelector('.color-circle');
            const subfolderCircle = subfolderScBtn.querySelector('.color-circle');
            const bothCircle = bothScBtn.querySelector('.color-circle');
            
            if (rootCircle) rootCircle.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--root-sc-color');
            if (subfolderCircle) subfolderCircle.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--subfolder-sc-color');
            if (bothCircle) bothCircle.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--both-sc-color');
        }

        function updateSelectionTypeButtons() {
            rootScBtn.classList.toggle('active', currentSelectionType === 'root-sc');
            subfolderScBtn.classList.toggle('active', currentSelectionType === 'subfolder-sc');
            bothScBtn.classList.toggle('active', currentSelectionType === 'both-sc');
        }

        function renderCanvas(canvasId) {
            if (!canvases.has(canvasId)) return;

            activeCanvasId = canvasId;
            thumbnailContainer.innerHTML = ''; // Clear container

            const canvas = canvases.get(canvasId);
            if (canvas && canvas.elements) {
                canvas.elements.forEach(el => {
                    thumbnailContainer.appendChild(el);
                });
            }

            populateCanvasDropdown();
            layoutLandscapeThumbnails(); // Re-layout after switching canvas
        }

        function populateCanvasDropdown() {
            canvasSelect.innerHTML = '';
            for (const canvas of canvases.values()) {
                const option = document.createElement('option');
                option.value = canvas.id;
                option.textContent = canvas.name;
                canvasSelect.appendChild(option);
            }
            if (canvases.has(activeCanvasId)) {
                canvasSelect.value = activeCanvasId;
            }
        }

        canvasSelect.addEventListener('change', (e) => {
            const newCanvasId = parseInt(e.target.value, 10);
            if (newCanvasId !== activeCanvasId) {
                renderCanvas(newCanvasId);
            }
        });

        async function findDirectoryHandleByName(dirHandle, name) {
            const lowerCaseName = name.toLowerCase();
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'directory' && entry.name.toLowerCase() === lowerCaseName) {
                    return entry;
                }
            }
            throw new Error(`Directory '${name}' not found.`);
        }

        function setVisibilityForMode(mode) {
            const checkboxContainers = document.querySelectorAll('.checkbox-container');

            const isDirectory = mode === 'directory';
            const isSc = mode === 'sc';
            const isScNew = mode === 'sc-new';
            const isLatestVideos = mode === 'latest-videos';
            const isRootSc = mode === 'root-sc';
            const isPlaylist = mode === 'playlist';

            deleteShortcutsBtn.style.display = isRootSc ? 'inline-block' : 'none';
            shortcutScriptBtn.style.display = (isRootSc || isPlaylist) ? 'none' : 'inline-block';
            createPlaylistBtn.style.display = isPlaylist ? 'inline-block' : 'none';
            xShortcutBtn.style.display = (isSc || isScNew) ? 'inline-block' : 'none';

            checkboxContainers.forEach(el => el.style.display = isDirectory ? 'flex' : 'none');
            canvasSelect.style.display = (isDirectory || isSc || isScNew || isLatestVideos || isRootSc || isPlaylist) ? 'inline-block' : 'none';
            groupSelector.style.display = isSc ? 'inline-block' : 'none';

            const showSelectionButtons = isLatestVideos || isPlaylist || isDirectory;
            rootScBtn.style.display = showSelectionButtons ? 'inline-block' : 'none';
            subfolderScBtn.style.display = showSelectionButtons ? 'inline-block' : 'none';
            bothScBtn.style.display = showSelectionButtons ? 'inline-block' : 'none';
            if (showSelectionButtons) {
                updateSelectionTypeButtons();
            }
        }

        showDatesCheckbox.addEventListener('change', () => {
            mainContainer.classList.toggle('show-dates', showDatesCheckbox.checked);
        });

        showOldThumbsCheckbox.addEventListener('change', () => {
            if (currentDirHandle) {
                if (currentMode === 'directory') {
                    renderDirectoryMode(sortSelector.value);
                } else if (currentMode === 'latest-videos') {
                    renderLatestVideosMode(sortSelector.value);
                } else if (currentMode === 'sc') {
                    renderScMode(sortSelector.value);
                }
            }
        });

        showNumbersCheckbox.addEventListener('change', updateRowNumbers);

        function updateContentSpacer() {
            const elements = document.querySelectorAll('.landscape-row, .project-header, hr');
            if (elements.length === 0) {
                contentSpacer.style.height = '0px';
                return;
            }
            let maxBottom = 0;
            elements.forEach(el => {
                const bottom = el.offsetTop + el.offsetHeight;
                if (bottom > maxBottom) maxBottom = bottom;
            });
            contentSpacer.style.height = (maxBottom + 20) + 'px';
        }

        function layoutLandscapeThumbnails() {
            const scale = parseFloat(sizeSelector.value);
            const elements = document.querySelectorAll('.landscape-row, .project-header, hr');

            elements.forEach(element => {
                if (element.classList.contains('landscape-row')) {
                    const thumbnails = element.querySelectorAll('.thumbnail');
                    thumbnails.forEach(thumb => {
                        const originalWidth = parseFloat(thumb.dataset.originalWidth);
                        const originalHeight = parseFloat(thumb.dataset.originalHeight);
                        const scaledWidth = originalWidth * scale;
                        const scaledHeight = originalHeight * scale;
                        thumb.style.width = scaledWidth + 'px';
                        thumb.style.height = scaledHeight + 'px';
                        thumb.style.marginRight = '10px';
                        thumb.style.marginBottom = '10px';
                    });
                }
            });
            updateRowNumbers();
            requestAnimationFrame(updateContentSpacer);
        }

        function escapePSString(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/'/g, "''");
        }

        function generateShortcutScript() {
            const selectionsToProcess = Array.from(shortcutSelections.values());
            const displayedProjectPaths = new Set(Array.from(canvases.values()).map(c => c.path));
            const selectedProjectPaths = new Set(selectionsToProcess.map(s => s.projectPath));
            const dummyTimestampProjects = new Set([...displayedProjectPaths].filter(p => !selectedProjectPaths.has(p)));

            let scriptLines = [
                '$PSScriptRoot = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition',
                '$wshell = New-Object -ComObject WScript.Shell',
                ''
            ];

            if (selectionsToProcess.length > 0) {
                 scriptLines.push('# --- Creating Shortcuts ---');
            }

            let needsRootSc = false;
            const subfolderProjects = new Set();
            selectionsToProcess.forEach(sel => {
                const selectionType = sel.type || 'root-sc';
                if (selectionType === 'root-sc' || selectionType === 'both-sc') {
                    needsRootSc = true;
                }
                if ((selectionType === 'subfolder-sc' || selectionType === 'both-sc') && sel.projectPath) {
                    subfolderProjects.add(sel.projectPath);
                }
            });

            if (needsRootSc) {
                scriptLines.push(`$rootScFolder = Join-Path -Path $PSScriptRoot -ChildPath 'sc'`);
                scriptLines.push('if (-not (Test-Path -LiteralPath $rootScFolder)) { New-Item -ItemType Directory -Path $rootScFolder | Out-Null }');
                scriptLines.push('');
            }
            
            subfolderProjects.forEach(projectPath => {
                const escapedProjectPath = escapePSString(projectPath);
                const subfolderScPath = `(Join-Path -Path (Join-Path -Path $PSScriptRoot -ChildPath '${escapedProjectPath}') -ChildPath 'sc')`;
                scriptLines.push(`if (-not (Test-Path -LiteralPath ${subfolderScPath})) { New-Item -ItemType Directory -Path ${subfolderScPath} | Out-Null }`);
            });
            if (subfolderProjects.size > 0) {
                scriptLines.push('');
            }

            selectionsToProcess.forEach(sel => {
                const escapedVideoName = escapePSString(sel.videoName);
                const escapedProjectPath = escapePSString(sel.projectPath);
                const escapedSubfolder = escapePSString(sel.subfolder);

                let targetPathConstruction = `$PSScriptRoot`;
                if (sel.projectPath) {
                    targetPathConstruction = `(Join-Path -Path ${targetPathConstruction} -ChildPath '${escapedProjectPath}')`;
                }
                if (sel.subfolder) {
                    targetPathConstruction = `(Join-Path -Path ${targetPathConstruction} -ChildPath '${escapedSubfolder}')`;
                }
                targetPathConstruction = `Join-Path -Path ${targetPathConstruction} -ChildPath '${escapedVideoName}'`;
                
                const selectionType = sel.type || 'root-sc';

                scriptLines.push(`    # Shortcut for: ${sel.projectPath}\\${sel.videoName} (Type: ${selectionType})`);
                scriptLines.push(`    $targetPath = ${targetPathConstruction}`);

                const createShortcut = (scPath) => {
                    scriptLines.push(`    $shortcutPath = ${scPath}`);
                    scriptLines.push('    $shortcut = $wshell.CreateShortcut($shortcutPath)');
                    scriptLines.push('    $shortcut.TargetPath = $targetPath');
                    scriptLines.push('    $shortcut.Save()');
                };

                if (selectionType === 'root-sc' || selectionType === 'both-sc') {
                    createShortcut(`Join-Path -Path $rootScFolder -ChildPath ('${escapedVideoName}' + '.lnk')`);
                }

                if (selectionType === 'subfolder-sc' || selectionType === 'both-sc') {
                    const subfolderScPath = `(Join-Path -Path (Join-Path -Path $PSScriptRoot -ChildPath '${escapedProjectPath}') -ChildPath 'sc')`;
                    createShortcut(`Join-Path -Path ${subfolderScPath} -ChildPath ('${escapedVideoName}' + '.lnk')`);
                }
                scriptLines.push('');
            });

            if (dummyTimestampProjects.size > 0) {
                const timestamp = new Date().toISOString();
                scriptLines.push('# --- Placing Dummy Timestamps ---');
                
                dummyTimestampProjects.forEach(projectPath => {
                    const escapedProjectPath = escapePSString(projectPath);
                    const projectPathVar = projectPath ? `Join-Path -Path $PSScriptRoot -ChildPath '${escapedProjectPath}'` : '$PSScriptRoot';

                    scriptLines.push(`Write-Host "Placing dummy timestamp for project: ${projectPath || '(Root)'}"`);
                    scriptLines.push(`$projectFolder = ${projectPathVar}`);
                    scriptLines.push(`$scDateFile = Join-Path -Path $projectFolder -ChildPath 'scdate.txt'`);
                    scriptLines.push(`Set-Content -Path $scDateFile -Value "dummy:${timestamp}"`);
                    scriptLines.push('');
                });
            }

            scriptLines.push('Write-Host "Script execution complete."');
            scriptLines.push('Read-Host -Prompt "Press Enter to exit"');

            const script = scriptLines.join('\r\n');
            batchScriptTextArea.value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
        }

        function generateXShortcutScript() {
            const groupedByProject = new Map();
            shortcutSelections.forEach((sel, key) => {
                if (!groupedByProject.has(sel.projectPath)) {
                    groupedByProject.set(sel.projectPath, []);
                }
                groupedByProject.get(sel.projectPath).push(sel.videoName);
            });

            let scriptLines = [
                '$PSScriptRoot = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition',
                '$wshell = New-Object -ComObject WScript.Shell',
                `$scFolder = Join-Path -Path $PSScriptRoot -ChildPath 'sc'`,
                ''
            ];

            scriptLines.push("# Create the 'sc' folder if it doesn't exist");
            scriptLines.push('if (-not (Test-Path -LiteralPath $scFolder)) {');
            scriptLines.push('    New-Item -ItemType Directory -Path $scFolder | Out-Null');
            scriptLines.push('}');
            scriptLines.push('');

            groupedByProject.forEach((videoNames, projectPath) => {
                const escapedProjectPath = escapePSString(projectPath);
                scriptLines.push(`$projectFolder = Join-Path -Path $PSScriptRoot -ChildPath '${escapedProjectPath}'`);
                scriptLines.push('');

                scriptLines.push('# List of video files');
                scriptLines.push('$videoFiles = @(');

                videoNames.forEach(videoName => {
                    scriptLines.push(`    '${escapePSString(videoName)}'`);
                });

                scriptLines.push(')');
                scriptLines.push('');

                scriptLines.push('foreach ($video in $videoFiles) {');
                scriptLines.push('    $targetPath = Join-Path -Path $projectFolder -ChildPath $video');
                scriptLines.push("    $shortcutPath = Join-Path -Path $scFolder -ChildPath ($video + '.lnk')");
                scriptLines.push('');
                scriptLines.push('    $shortcut = $wshell.CreateShortcut($shortcutPath)');
                scriptLines.push('    $shortcut.TargetPath = $targetPath');
                scriptLines.push('    $shortcut.Save()');
                scriptLines.push('}');
                scriptLines.push('');
            });

            scriptLines.push('Write-Host "Shortcut creation complete."');
            scriptLines.push('Read-Host -Prompt "Press Enter to exit"');

            const script = scriptLines.join('\r\n');
            batchScriptTextArea.value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
        }

        function getNextCanvasId() {
            let i = 1;
            while (canvases.has(i)) {
                i++;
            }
            return i;
        }

        function normalizeLine(line) {
            return line.trim().replace(/^["']|["']$/g, '').toLowerCase();
        }

        function normalizeProjectKey(key) {
            return key.trim().replace(/^[\\/"']+|[\\/"']+$/g, '').replace(/\\/g, '/').toLowerCase();
        }

        async function getScDataForProject(projectHandle) {
            try {
                const handle = await projectHandle.getFileHandle('scdata.txt');
                const file = await handle.getFile();
                const text = await file.text();
                const data = new Set(text.split('\n').map(normalizeLine).filter(l => l));
                console.log(`Loaded ${data.size} shortcuts from project scdata.txt: ${projectHandle.name}`);
                return data;
            } catch (e) {
                return new Set();
            }
        }

        async function getRootScData(rootHandle) {
            try {
                const handle = await rootHandle.getFileHandle('scdata.txt');
                const file = await handle.getFile();
                const text = await file.text();
                const data = parseRootScData(text); // Map<subfolder, Array<filename>>
                console.log(`Loaded root scdata.txt from ${rootHandle.name}. Projects found: ${data.size}`);
                return data;
            } catch (e) {
                return new Map();
            }
        }

        function checkShortcut(videoName, scDataSet) {
            const baseName = videoName.substring(0, videoName.lastIndexOf('.'));
            const namesToCheck = [
                videoName.toLowerCase() + ".lnk",
                videoName.toLowerCase() + ".ink",
                videoName.toLowerCase()
            ];
            if (baseName) {
                namesToCheck.push(baseName.toLowerCase() + ".lnk");
                namesToCheck.push(baseName.toLowerCase() + ".ink");
                namesToCheck.push(baseName.toLowerCase());
            }
            return namesToCheck.some(n => scDataSet.has(n));
        }

        // Function to safely read and parse scdate.txt
        // Returns null if the file is missing or invalid
        async function getTimestamp(dirHandle) {
            try {
                const scDateHandle = await dirHandle.getFileHandle('scdate.txt');
                const file = await scDateHandle.getFile();
                let text = await file.text();
                if (text.startsWith('dummy:')) {
                    text = text.substring(6);
                }
                const raw = text.trim();
                if (!raw) return null;
                const date = raw.endsWith('Z') ? new Date(raw) : new Date(raw + 'Z');
                if (!isNaN(date)) {
                    return date.getTime();
                }
            } catch (e) {
                // scdate.txt doesn't exist or is invalid
            }
            return null;
        }

        async function renderDirectoryMode(sortBy = 'name-asc') {
            await renderVideosInternal(false, sortBy);
        }

        async function renderLatestVideosMode(sortBy = 'name-asc') {
            await renderVideosInternal(true, sortBy);
        }

        async function renderVideosInternal(isNewOnly = false, sortBy = 'name-asc') {
            console.log(`Starting renderVideosInternal (isNewOnly=${isNewOnly})`);
            createdObjectUrls.forEach(URL.revokeObjectURL);
            createdObjectUrls = [];
            canvases.clear();
            shortcutSelections.clear();
            thumbnailContainer.innerHTML = '';
            allVideoFiles = [];

            const projectFolders = [];

            async function findProjectFolders(dirHandle, currentPath = '') {
                 for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'directory') {
                        const newPath = currentPath ? `${currentPath}\\${entry.name}` : entry.name;
                        try {
                            await findDirectoryHandleByName(entry, 'Edit Thumbnails');
                            
                            let timestamp = 0;
                            if (isNewOnly) {
                                timestamp = await getTimestamp(entry);
                                if (timestamp === null) {
                                    console.log(`Skipping project ${entry.name} in New Videos mode because scdate.txt is missing.`);
                                    continue; 
                                }
                            }

                            projectFolders.push({ 
                                handle: entry, 
                                path: newPath, 
                                name: entry.name,
                                timestamp: timestamp 
                            });
                        } catch (e) {
                           await findProjectFolders(entry, newPath);
                        }
                    }
                }
            }
            
            try {
                await findDirectoryHandleByName(currentDirHandle, 'Edit Thumbnails');
                let timestamp = 0;
                if (isNewOnly) {
                    timestamp = await getTimestamp(currentDirHandle);
                    // If the user selected a project directly and it has no scdate.txt,
                    // we'll still load it but with timestamp 0? 
                    // No, the clarification says "choice to load... is dependent on... scdate.txt".
                    // So if it's missing, we don't load it.
                    if (timestamp === null) {
                        alert('This project does not have an scdate.txt file and cannot be loaded in "New Videos" mode.');
                        return;
                    }
                }
                projectFolders.push({ 
                    handle: currentDirHandle, 
                    path: '', 
                    name: currentDirHandle.name,
                    timestamp: timestamp
                });
            } catch (e) {
                await findProjectFolders(currentDirHandle);
            }

            projectFolders.sort((a, b) => a.name.localeCompare(b.name));

            let rootScData = new Map();
            let currentDirScData = await getRootScData(currentDirHandle);
            
            if (currentDirScData.size > 0) {
                // currentDirHandle is root
                g_rootHandle = currentDirHandle;
                rootScData = currentDirScData;
            } else if (g_rootHandle) {
                // already have root handle
                rootScData = await getRootScData(g_rootHandle);
            } else {
                // project selected directly or root scdata.txt missing
                // Check if it's a project
                let isProject = false;
                try {
                    await findDirectoryHandleByName(currentDirHandle, 'Edit Thumbnails');
                    isProject = true;
                } catch (e) {}

                if (isProject || projectFolders.length > 0) {
                    if (confirm("Would you like to select the root folder to enable root shortcut detection?")) {
                        try {
                            const rootHandle = await window.showDirectoryPicker();
                            g_rootHandle = rootHandle;
                            rootScData = await getRootScData(g_rootHandle);
                        } catch (e) {}
                    }
                }
            }

            if (projectFolders.length === 0) {
                alert('No "Edit Thumbnails" folders found in the selected directory or its subdirectories.');
                return;
            }

            const allImageLoadPromises = [];
            for (const project of projectFolders) {
                console.log(`Processing project: ${project.name} (Path: ${project.path})`);
                const projectScData = await getScDataForProject(project.handle);
                
                const normalizedProjectName = normalizeProjectKey(project.name);
                const normalizedProjectPath = normalizeProjectKey(project.path);
                
                let rootProjectShortcuts = rootScData.get(normalizedProjectName) || [];
                if (rootProjectShortcuts.length === 0 && normalizedProjectPath && normalizedProjectPath !== normalizedProjectName) {
                    rootProjectShortcuts = rootScData.get(normalizedProjectPath) || [];
                }
                const rootProjectShortcutsSet = new Set(rootProjectShortcuts);

                const canvasId = getNextCanvasId();
                const canvasElements = [];

                let mostRecentShortcutTime = project.timestamp || 0;

                const projectVideoFiles = [];
                // Recursively find videos in subfolders
                async function findVideos(dirHandle, subfolder = '') {
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file' && entry.name.match(/\.(mp4|avi|mov|mkv)$/i)) {
                            const file = await entry.getFile();
                            if (!isNewOnly || file.lastModified > mostRecentShortcutTime) {
                                // Store additional path info on the file object
                                file.subfolder = subfolder;
                                file.projectPath = project.path;
                                projectVideoFiles.push(file);
                            } else if (isNewOnly) {
                                console.log(`Filtering out old video: ${entry.name} (Modified: ${new Date(file.lastModified).toLocaleString()}, Cutoff: ${new Date(mostRecentShortcutTime).toLocaleString()})`);
                            }
                        } else if (entry.kind === 'directory' && entry.name.toLowerCase() !== 'edit thumbnails' && entry.name.toLowerCase() !== 'thumbnails' && entry.name.toLowerCase() !== 'sc') {
                            await findVideos(entry, subfolder ? `${subfolder}\\${entry.name}` : entry.name);
                        }
                    }
                }
                await findVideos(project.handle);
                allVideoFiles.push(...projectVideoFiles);

                const editDirHandle = await findDirectoryHandleByName(project.handle, 'Edit Thumbnails');
                const landscapeFiles = [];
                 for await (const entry of editDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.match(/\.(jpe?g|png|gif|webp)$/i)) {
                        landscapeFiles.push(await entry.getFile());
                    }
                }

                const groupedFiles = landscapeFiles.reduce((acc, file) => {
                    const match = file.name.match(/^(.*?)_(\d+)\.[^.]+$/);
                    if (match) {
                        const videoName = match[1];
                        if (!acc[videoName]) acc[videoName] = [];
                        acc[videoName].push(file);
                    }
                    return acc;
                }, {});

                let videoNames = Object.keys(groupedFiles);
                const videoFileMap = new Map(allVideoFiles.map(f => [f.name.substring(0, f.name.lastIndexOf('.')), f]));

                videoNames = videoNames.filter(name => videoFileMap.has(name));

                if (videoNames.length === 0) continue;

                videoNames.sort((a, b) => {
                    if (sortBy === 'name-asc') return a.localeCompare(b);
                    if (sortBy === 'name-desc') return b.localeCompare(a);
                    const fileA = videoFileMap.get(a);
                    const fileB = videoFileMap.get(b);
                    const dateA = fileA ? fileA.lastModified : 0;
                    const dateB = fileB ? fileB.lastModified : 0;
                    if (sortBy === 'date-new') return dateB - dateA;
                    if (sortBy === 'date-old') return dateA - dateB;
                    return 0;
                });

                const header = document.createElement('h2');
                header.className = 'project-header';

                const headerText = document.createElement('span');
                headerText.textContent = project.name;
                header.appendChild(headerText);

                if (isNewOnly) {
                    const headerDateInfo = document.createElement('span');
                    headerDateInfo.className = 'date-info';
                    headerDateInfo.textContent = `Last Shortcut: ${new Date(mostRecentShortcutTime).toLocaleString()}`;
                    header.appendChild(headerDateInfo);
                }

                canvasElements.push(header);

                for (const videoName of videoNames) {
                    const files = groupedFiles[videoName].sort((a, b) => {
                        const aNum = parseInt(a.name.substring(a.name.lastIndexOf('_') + 1));
                        const bNum = parseInt(b.name.substring(b.name.lastIndexOf('_') + 1));
                        return aNum - bNum;
                    });

                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'landscape-row';
                    rowDiv.dataset.videoName = videoName;
                    rowDiv.dataset.projectPath = project.path;
                    
                    const videoFile = videoFileMap.get(videoName);
                    if (!videoFile) continue;

                    const dateInfo = document.createElement('span');
                    dateInfo.className = 'date-info';
                    dateInfo.textContent = `Created: ${new Date(videoFile.lastModified).toLocaleString()}`;
                    rowDiv.appendChild(dateInfo);

                    const hasProjectSc = checkShortcut(videoFile.name, projectScData);
                    const hasRootSc = checkShortcut(videoFile.name, rootProjectShortcutsSet);

                    if (hasProjectSc) console.log(`Match found in project scdata for: ${videoFile.name}`);
                    if (hasRootSc) console.log(`Match found in root scdata for: ${videoFile.name}`);

                    let initialShortcutType = '';
                    if (hasProjectSc && hasRootSc) initialShortcutType = 'both-sc';
                    else if (hasProjectSc) initialShortcutType = 'subfolder-sc';
                    else if (hasRootSc) initialShortcutType = 'root-sc';

                    if (initialShortcutType) {
                        const key = project.path + '|' + videoFile.name;
                        shortcutSelections.set(key, {
                            videoName: videoFile.name, 
                            projectPath: project.path,
                            subfolder: videoFile.subfolder,
                            type: initialShortcutType
                        });
                    }

                    canvasElements.push(rowDiv);

                    rowDiv.addEventListener('click', () => {
                        const selectionData = {
                            videoName: videoFile.name,
                            projectPath: project.path,
                            subfolder: videoFile.subfolder,
                            type: currentSelectionType
                        };
                        const key = project.path + '|' + videoFile.name;
                        const existingSelection = shortcutSelections.get(key);

                        // Clear previous selection visuals from this row
                        rowDiv.querySelectorAll('.thumbnail').forEach(t => {
                            t.classList.remove('selected-root-sc', 'selected-subfolder-sc', 'selected-both-sc', 'selected-shortcut');
                        });

                        if (existingSelection) {
                            shortcutSelections.delete(key);
                        }

                        // If the new selection is different from the old one, or if there was no old one, add it.
                        if (!existingSelection || existingSelection.type !== currentSelectionType) {
                            rowDiv.querySelectorAll('.thumbnail').forEach(t => t.classList.add('selected-' + currentSelectionType));
                            shortcutSelections.set(key, selectionData);
                        }
                    });

                    files.forEach(file => {
                        const img = new Image();
                        img.className = 'thumbnail';
                        img.dataset.fileName = file.name;
                        if (initialShortcutType) {
                            img.classList.add('selected-' + initialShortcutType);
                        }
                        rowDiv.appendChild(img);
                        
                        const promise = new Promise((resolve, reject) => {
                            img.onload = () => {
                                img.dataset.originalWidth = img.width;
                                img.dataset.originalHeight = img.height;
                                resolve();
                            };
                            img.onerror = reject;
                        });
                        
                        const url = URL.createObjectURL(file);
                        createdObjectUrls.push(url);
                        img.src = url;
                        allImageLoadPromises.push(promise);
                    });
                }
                 if (videoNames.length > 0) {
                    const hr = document.createElement('hr');
                    canvasElements.push(hr);
                    canvases.set(canvasId, { id: canvasId, name: project.name, elements: canvasElements, path: project.path });
                }
            }
            await Promise.all(allImageLoadPromises);
            if (canvases.size > 0) {
                renderCanvas(canvases.keys().next().value);
            } else {
                populateCanvasDropdown(); // Ensure dropdown is cleared if no projects found
                thumbnailContainer.innerHTML = ''; // Clear display area
            }
        }

        function populateGroupSelector() {
            groupSelector.innerHTML = '';
            const groupCount = Math.ceil(allProjectFolders.length / 10);
            for (let i = 0; i < groupCount; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Group ${i + 1}`;
                groupSelector.appendChild(option);
            }
        }

        async function renderScGroup(groupIndex = 0, sortBy = 'name-asc') {
            const start = groupIndex * 10;
            const end = start + 10;
            const projectsToRender = allProjectFolders.slice(start, end);

            canvases.clear();
            createdObjectUrls.forEach(URL.revokeObjectURL);
            createdObjectUrls = [];

            const videoExtensionRegex = /\.(mp4|avi|mov|mkv)$/i;
            const displayableProjects = new Map();

            async function findVideosInDirectory(dirHandle) {
                const videoFiles = [];
                for await (const fileEntry of dirHandle.values()) {
                    if (fileEntry.kind === 'file' && fileEntry.name.match(videoExtensionRegex)) {
                        videoFiles.push(await fileEntry.getFile());
                    }
                }
                return videoFiles;
            }

            for (const project of projectsToRender) {
                const scdataHandle = await project.handle.getFileHandle('scdata.txt');
                const scdata = await (await scdataHandle.getFile()).text();
                const videoFiles = await findVideosInDirectory(project.handle);

                const shortcutFileNames = scdata.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0)
                    .map(name => name.replace(/^'|'$/g, '').replace(/\.lnk$/, ''));

                const videosInProject = [];
                videoFiles.forEach(videoFile => {
                    const videoFileBaseName = videoFile.name.replace(videoExtensionRegex, '');
                    if (shortcutFileNames.some(name => name.startsWith(videoFileBaseName))) {
                        videosInProject.push({
                            videoFile: videoFile,
                            videoName: videoFile.name,
                        });
                    }
                });

                if (videosInProject.length > 0) {
                    videosInProject.sort((a, b) => {
                        if (sortBy === 'name-asc') return a.videoName.localeCompare(b.videoName);
                        if (sortBy === 'name-desc') return b.videoName.localeCompare(a.videoName);
                        const dateA = a.videoFile.lastModified;
                        const dateB = b.videoFile.lastModified;
                        if (sortBy === 'date-new') return dateB - dateA;
                        if (sortBy === 'date-old') return dateA - dateB;
                        return 0;
                    });
                    displayableProjects.set(project.path, {
                        handle: project.handle,
                        videos: videosInProject
                    });
                }
            }

            const allImageLoadPromises = [];
            for (const [projectPath, projectData] of displayableProjects.entries()) {
                const canvasId = getNextCanvasId();
                const canvasElements = [];

                const header = document.createElement('h2');
                header.className = 'project-header';
                header.textContent = projectData.handle.name;
                canvasElements.push(header);

                for (const videoInfo of projectData.videos) {
                    try {
                        const editDirHandle = await findDirectoryHandleByName(projectData.handle, 'Edit Thumbnails');
                        const landscapeFiles = [];
                        for await (const entry of editDirHandle.values()) {
                            if (entry.kind === 'file' && entry.name.startsWith(videoInfo.videoName.substring(0, videoInfo.videoName.lastIndexOf('.')))) {
                                landscapeFiles.push(await entry.getFile());
                            }
                        }

                        const files = landscapeFiles.sort((a, b) => {
                            const aNum = parseInt(a.name.substring(a.name.lastIndexOf('_') + 1));
                            const bNum = parseInt(b.name.substring(b.name.lastIndexOf('_') + 1));
                            return aNum - bNum;
                        });

                        const rowDiv = document.createElement('div');
                        rowDiv.className = 'landscape-row';
                        rowDiv.dataset.videoName = videoInfo.videoName;
                        rowDiv.dataset.projectPath = projectPath;

                        const selectionData = {
                            videoName: videoInfo.videoFile.name,
                            projectPath: projectPath,
                            subfolder: videoInfo.videoFile.subfolder
                        };
                        const key = projectPath + '|' + videoInfo.videoFile.name;
                        if (shortcutSelections.has(key)) {
                            rowDiv.classList.add('selected-shortcut');
                        }

                        canvasElements.push(rowDiv);

                        rowDiv.addEventListener('click', () => {
                            rowDiv.classList.toggle('selected-shortcut');
                            if (shortcutSelections.has(key)) {
                                shortcutSelections.delete(key);
                            } else {
                                shortcutSelections.set(key, selectionData);
                            }
                        });

                        files.forEach(file => {
                            const img = new Image();
                            img.className = 'thumbnail';
                            img.dataset.fileName = file.name;
                            rowDiv.appendChild(img);

                            const promise = new Promise((resolve, reject) => {
                                img.onload = () => {
                                    img.dataset.originalWidth = img.width;
                                    img.dataset.originalHeight = img.height;
                                    resolve();
                                };
                                img.onerror = reject;
                            });

                            const url = URL.createObjectURL(file);
                            createdObjectUrls.push(url);
                            img.src = url;
                            allImageLoadPromises.push(promise);
                        });
                    } catch (e) {
                        const errorDiv = document.createElement('div');
                        errorDiv.textContent = `Error: Could not find or access 'Edit Thumbnails' directory in project: ${projectData.handle.name}`;
                        errorDiv.style.color = 'red';
                        canvasElements.push(errorDiv);
                    }
                }
                const hr = document.createElement('hr');
                canvasElements.push(hr);
                canvases.set(canvasId, { id: canvasId, name: projectData.handle.name, elements: canvasElements, path: projectPath });
            }

            await Promise.all(allImageLoadPromises);

             if (canvases.size > 0) {
                renderCanvas(canvases.keys().next().value);
            } else {
                populateCanvasDropdown();
                thumbnailContainer.innerHTML = '';
            }
        }

        async function renderScNewMode() {
            console.log("--- Starting renderScNewMode (v2) ---");
            thumbnailContainer.innerHTML = '';
            canvases.clear();
            shortcutSelections.clear();
            createdObjectUrls.forEach(URL.revokeObjectURL);
            createdObjectUrls = [];

            try {
                const scnewHandle = await currentDirHandle.getFileHandle('scnew.txt');
                const scnewFile = await scnewHandle.getFile();
                const scnewText = await scnewFile.text();
                const shortcutPaths = scnewText.split('\n').map(line => line.trim()).filter(line => line);

                if (shortcutPaths.length === 0) {
                    thumbnailContainer.innerHTML = '<p style="color: black;">scnew.txt is empty. No new shortcuts to display.</p>';
                    return;
                }
                
                const groupedBySubfolder = new Map();
                for (const path of shortcutPaths) {
                    const parts = path.split('\\');
                    if (parts.length >= 3) {
                        const subfolderName = parts[parts.length - 3];
                        const shortcutFileName = parts[parts.length - 1];
                        
                        if (!groupedBySubfolder.has(subfolderName)) {
                            groupedBySubfolder.set(subfolderName, []);
                        }
                        groupedBySubfolder.get(subfolderName).push(shortcutFileName);
                    }
                }

                const allImageLoadPromises = [];
                for (const [subfolderName, shortcutFileNames] of groupedBySubfolder.entries()) {
                    console.log(`Processing subfolder: ${subfolderName}`);
                    const subfolderHandle = await currentDirHandle.getDirectoryHandle(subfolderName);
                    const editDirHandle = await findDirectoryHandleByName(subfolderHandle, 'Edit Thumbnails');

                    const canvasId = getNextCanvasId();
                    const canvasElements = [];
                    const header = document.createElement('h2');
                    header.className = 'project-header';
                    header.textContent = subfolderName;
                    canvasElements.push(header);

                    for (const shortcutFileName of shortcutFileNames) {
                        const videoBaseName = shortcutFileName.slice(0, -4);
                        const videoNameWithoutExt = videoBaseName.substring(0, videoBaseName.lastIndexOf('.'));

                        const landscapeFiles = [];
                        for await (const entry of editDirHandle.values()) {
                            if (entry.kind === 'file' && entry.name.startsWith(videoNameWithoutExt)) {
                                landscapeFiles.push(await entry.getFile());
                            }
                        }

                        if (landscapeFiles.length > 0) {
                             landscapeFiles.sort((a, b) => {
                                const aNum = parseInt(a.name.substring(a.name.lastIndexOf('_') + 1));
                                const bNum = parseInt(b.name.substring(b.name.lastIndexOf('_') + 1));
                                return aNum - bNum;
                            });

                            const rowDiv = document.createElement('div');
                            rowDiv.className = 'landscape-row';
                            rowDiv.dataset.videoName = videoBaseName;
                            rowDiv.dataset.projectPath = subfolderName;
                            canvasElements.push(rowDiv);

                             rowDiv.addEventListener('click', () => {
                                rowDiv.classList.toggle('selected-shortcut');
                                const selectionData = { videoName: videoBaseName, projectPath: subfolderName };
                                const key = subfolderName + '|' + videoBaseName;
                                if (shortcutSelections.has(key)) {
                                    shortcutSelections.delete(key);
                                } else {
                                    shortcutSelections.set(key, selectionData);
                                }
                            });

                             landscapeFiles.forEach(file => {
                                const img = new Image();
                                img.className = 'thumbnail';
                                img.dataset.fileName = file.name;
                                rowDiv.appendChild(img);
                                const promise = new Promise((resolve, reject) => {
                                    img.onload = () => {
                                        img.dataset.originalWidth = img.width;
                                        img.dataset.originalHeight = img.height;
                                        resolve();
                                    };
                                    img.onerror = reject;
                                });
                                const url = URL.createObjectURL(file);
                                createdObjectUrls.push(url);
                                img.src = url;
                                allImageLoadPromises.push(promise);
                            });
                        }
                    }
                     if (canvasElements.length > 1) { // Only add if there are more than just the header
                        canvases.set(canvasId, { id: canvasId, name: subfolderName, elements: canvasElements, path: subfolderName });
                    }
                }

                await Promise.all(allImageLoadPromises);

                if (canvases.size > 0) {
                    renderCanvas(canvases.keys().next().value);
                } else {
                    populateCanvasDropdown();
                    thumbnailContainer.innerHTML = '<p style="color: black;">No new shortcuts found to display.</p>';
                }

            } catch (err) {
                console.error("Caught error in renderScNewMode:", err);
                thumbnailContainer.innerHTML = `<p style="color: red;">Error: Could not read or process scnew.txt. Please ensure the file exists and is correctly formatted.</p><p style="color: red; font-size: 0.8em;">${err.message}</p>`;
            }
        }

        async function renderScMode(sortBy = 'name-asc') {
            createdObjectUrls.forEach(URL.revokeObjectURL);
            createdObjectUrls = [];
            canvases.clear();
            allProjectFolders = [];

            const discoveredProjects = [];

            async function findScDataFiles(dirHandle, currentPath = '') {
                try {
                    await dirHandle.getFileHandle('scdata.txt');
                    discoveredProjects.push({
                        handle: dirHandle,
                        path: currentPath,
                        name: dirHandle.name
                    });
                } catch (e) {
                    // Not a project folder.
                }

                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'directory') {
                        const newPath = currentPath ? `${currentPath}\\${entry.name}` : entry.name;
                        await findScDataFiles(entry, newPath);
                    }
                }
            }

            try {
                await findScDataFiles(currentDirHandle, '');

                if (discoveredProjects.length === 0) {
                    console.log('No projects with scdata.txt found.');
                    return;
                }

                allProjectFolders = discoveredProjects.sort((a, b) => a.name.localeCompare(b.name));
                populateGroupSelector();
                await renderScGroup(0, sortBy);

            } catch (err) {
                console.error(`A critical error occurred during the SC Mode process:\n\n${err.stack}`);
            }
        }

        async function renderPlaylistMode() {
            thumbnailContainer.innerHTML = '';
            canvases.clear();
            shortcutSelections.clear();
            createdObjectUrls.forEach(URL.revokeObjectURL);
            createdObjectUrls = [];

            const projectFolders = [];
            for await (const entry of currentDirHandle.values()) {
                if (entry.kind === 'directory') {
                    projectFolders.push({ handle: entry, path: entry.name, name: entry.name });
                }
            }
            projectFolders.sort((a, b) => a.name.localeCompare(b.name));

            if (projectFolders.length === 0) {
                alert('No subdirectories found.');
                return;
            }

            const allImageLoadPromises = [];
            const canvasId = getNextCanvasId();
            const canvasElements = [];

            for (const project of projectFolders) {
                try {
                    const videoFiles = [];
                    async function findVideos(dirHandle) {
                        for await (const entry of dirHandle.values()) {
                            if (entry.kind === 'file' && entry.name.match(/\.(mp4|avi|mov|mkv)$/i)) {
                                videoFiles.push(entry);
                            }
                        }
                    }
                    await findVideos(project.handle);

                    if (videoFiles.length === 0) continue;

                    videoFiles.sort((a, b) => a.name.localeCompare(b.name));
                    const firstVideo = videoFiles[0];
                    const videoBaseName = firstVideo.name.substring(0, firstVideo.name.lastIndexOf('.'));

                    const editDirHandle = await project.handle.getDirectoryHandle('Edit Thumbnails');
                    const thumbnailFiles = [];
                    for await (const entry of editDirHandle.values()) {
                        if (entry.kind === 'file' && entry.name.startsWith(videoBaseName)) {
                            thumbnailFiles.push(await entry.getFile());
                        }
                    }

                    if (thumbnailFiles.length === 0) continue;

                    thumbnailFiles.sort((a, b) => {
                        const aNum = parseInt(a.name.substring(a.name.lastIndexOf('_') + 1));
                        const bNum = parseInt(b.name.substring(b.name.lastIndexOf('_') + 1));
                        return aNum - bNum;
                    });

                    const header = document.createElement('h2');
                    header.className = 'project-header';
                    header.textContent = project.name;
                    canvasElements.push(header);

                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'landscape-row';
                    rowDiv.dataset.projectPath = project.path;
                    canvasElements.push(rowDiv);

                    rowDiv.addEventListener('click', () => {
                        const selectionData = { projectPath: project.path, type: currentSelectionType };
                        const key = project.path + '|playlist_entry';
                        const existingSelection = shortcutSelections.get(key);

                        const allThumbnailsInRow = rowDiv.querySelectorAll('.thumbnail');
                        allThumbnailsInRow.forEach(t => t.classList.remove('selected-root-sc', 'selected-subfolder-sc', 'selected-both-sc'));
                        
                        if (existingSelection) {
                            shortcutSelections.delete(key);
                        }

                        if (!existingSelection || existingSelection.type !== currentSelectionType) {
                            allThumbnailsInRow.forEach(t => t.classList.add('selected-' + currentSelectionType));
                            shortcutSelections.set(key, selectionData);
                        }
                    });

                    thumbnailFiles.forEach(file => {
                        const img = new Image();
                        img.className = 'thumbnail';
                        img.dataset.projectPath = project.path;
                        rowDiv.appendChild(img);

                        const promise = new Promise((resolve, reject) => {
                            img.onload = () => {
                                img.dataset.originalWidth = img.width;
                                img.dataset.originalHeight = img.height;
                                resolve();
                            };
                            img.onerror = reject;
                        });

                        const url = URL.createObjectURL(file);
                        createdObjectUrls.push(url);
                        img.src = url;
                        allImageLoadPromises.push(promise);
                    });

                } catch (e) {
                    console.warn(`Could not process project '${project.name}' for playlist mode:`, e);
                }
            }
            
            canvases.set(canvasId, { id: canvasId, name: 'Playlist View', elements: canvasElements, path: '' });
            await Promise.all(allImageLoadPromises);
            renderCanvas(canvasId);
        }

        function generatePlaylistScript() {
            let scriptLines = [
                '$PSScriptRoot = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition',
                '$playlistContent = New-Object System.Collections.Generic.List[string]',
                '$wshell = New-Object -ComObject WScript.Shell',
                ''
            ];

            const selections = Array.from(shortcutSelections.values());
            const rootScSelections = selections.filter(s => s.type === 'root-sc' || s.type === 'both-sc');
            const subfolderScSelections = selections.filter(s => s.type === 'subfolder-sc' || s.type === 'both-sc');

            if (rootScSelections.length > 0) {
                scriptLines.push("# --- Processing Root SC Selections ---");
                scriptLines.push(`$rootScFolder = Join-Path -Path $PSScriptRoot -ChildPath 'sc'`);
                scriptLines.push(`if (Test-Path -LiteralPath $rootScFolder) {`);
                scriptLines.push(`    $shortcuts = Get-ChildItem -Path $rootScFolder -Filter *.lnk`);
                scriptLines.push(`    foreach ($shortcutFile in $shortcuts) {`);
                scriptLines.push(`        $shortcut = $wshell.CreateShortcut($shortcutFile.FullName)`);
                scriptLines.push(`        $targetPath = $shortcut.TargetPath`);
                
                rootScSelections.forEach(sel => {
                    const escapedProjectPath = escapePSString(sel.projectPath);
                    scriptLines.push(`        $projectCheckPath = Join-Path -Path $PSScriptRoot -ChildPath '${escapedProjectPath}'`);
                    scriptLines.push(`        if ($targetPath.StartsWith($projectCheckPath)) {`);
                    scriptLines.push(`            if (-not $playlistContent.Contains($targetPath)) { $playlistContent.Add($targetPath) }`);
                    scriptLines.push(`        }`);
                });

                scriptLines.push(`    }`);
                scriptLines.push(`}`);
                scriptLines.push('');
            }

            if (subfolderScSelections.length > 0) {
                scriptLines.push("# --- Processing Subfolder SC Selections ---");
                subfolderScSelections.forEach(sel => {
                    const escapedProjectPath = escapePSString(sel.projectPath);
                    scriptLines.push(`    $subfolderScPath = Join-Path -Path $PSScriptRoot -ChildPath (Join-Path -Path '${escapedProjectPath}' -ChildPath 'sc')`);
                    scriptLines.push(`    if (Test-Path -LiteralPath $subfolderScPath) {`);
                    scriptLines.push(`        Get-ChildItem -Path $subfolderScPath -Filter *.lnk | ForEach-Object {`);
                    scriptLines.push(`            $shortcut = $wshell.CreateShortcut($_.FullName)`);
                    scriptLines.push(`            $targetPath = $shortcut.TargetPath`);
                    scriptLines.push(`            if (-not $playlistContent.Contains($targetPath)) { $playlistContent.Add($targetPath) }`);
                    scriptLines.push(`        }`);
                    scriptLines.push(`    }`);
                });
                scriptLines.push('');
            }

            scriptLines.push(`$playlistPath = Join-Path -Path $PSScriptRoot -ChildPath "playlist.m3u"`);
            scriptLines.push(`$uniqueContent = $playlistContent | Sort-Object | Get-Unique`);
            scriptLines.push(`$uniqueContent | Out-File -FilePath $playlistPath -Encoding utf8`);
            scriptLines.push(`Write-Host "Playlist created at: $playlistPath"`);
            scriptLines.push('Read-Host -Prompt "Press Enter to exit"');

            const script = scriptLines.join('\r\n');
            batchScriptTextArea.value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
            downloadScriptLink.download = 'create_playlist.ps1';
        }

        async function renderRootScMode() {
            shortcutSelections.clear();
            canvases.clear();
            createdObjectUrls.forEach(URL.revokeObjectURL);
            createdObjectUrls = [];

            let scdataContents;
            try {
                const scdataHandle = await currentDirHandle.getFileHandle('scdata.txt');
                const scdataFile = await scdataHandle.getFile();
                scdataContents = await scdataFile.text();
            } catch (e) {
                console.error('Failed to read scdata.txt:', e);
                alert('scdata.txt not found in the selected directory.');
                return;
            }

            const scdata = parseRootScData(scdataContents);
            if (scdata.size === 0) {
                thumbnailContainer.innerHTML = '<p style="color: black;">No subfolders found in scdata.txt.</p>';
                return;
            }
            g_rootHandle = currentDirHandle;

            const allImageLoadPromises = [];
            const sortedSubfolders = Array.from(scdata.keys()).sort((a, b) => a.localeCompare(b));

            for (const subfolder of sortedSubfolders) {
                const shortcutFiles = scdata.get(subfolder);
                const canvasId = getNextCanvasId();
                const canvasElements = [];

                const header = document.createElement('h2');
                header.className = 'project-header';
                header.textContent = subfolder;
                canvasElements.push(header);

                let subfolderHandle;
                try {
                    subfolderHandle = await currentDirHandle.getDirectoryHandle(subfolder);
                } catch (e) {
                    console.error(`Could not get directory handle for "${subfolder}". Skipping.`, e);
                    continue;
                }

                let editDirHandle;
                try {
                    editDirHandle = await subfolderHandle.getDirectoryHandle('Edit Thumbnails');
                } catch (e) {
                    console.error(`Could not get 'Edit Thumbnails' directory handle for "${subfolder}". Skipping.`, e);
                    continue;
                }

                for (const shortcutFile of shortcutFiles) {
                    const videoBaseName = shortcutFile.substring(0, shortcutFile.lastIndexOf('.'));

                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'landscape-row';
                    rowDiv.dataset.shortcutName = shortcutFile + '.lnk';

                    const thumbnailFiles = [];
                    try {
                        for await (const entry of editDirHandle.values()) {
                            if (entry.kind === 'file' && entry.name.toLowerCase().startsWith(videoBaseName.toLowerCase())) {
                                thumbnailFiles.push(await entry.getFile());
                            }
                        }
                    } catch (e) {
                        console.error(`Failed while iterating 'Edit Thumbnails' for "${subfolder}".`, e);
                        continue;
                    }

                    if (thumbnailFiles.length > 0) {
                        canvasElements.push(rowDiv); // Only add the row if thumbnails were found

                        thumbnailFiles.sort((a, b) => {
                            const aNum = parseInt(a.name.substring(a.name.lastIndexOf('_') + 1));
                            const bNum = parseInt(b.name.substring(b.name.lastIndexOf('_') + 1));
                            return aNum - bNum;
                        });

                        rowDiv.addEventListener('click', () => {
                            const isSelected = !rowDiv.querySelector('.thumbnail.selected-shortcut');
                            rowDiv.querySelectorAll('.thumbnail').forEach(t => {
                                t.classList.toggle('selected-shortcut', isSelected);
                            });
                            const shortcutName = rowDiv.dataset.shortcutName;
                            const key = 'root_sc|' + shortcutName;
                            if (isSelected) {
                                shortcutSelections.set(key, shortcutName);
                            } else {
                                shortcutSelections.delete(key);
                            }
                        });

                        thumbnailFiles.forEach(file => {
                            const img = new Image();
                            img.className = 'thumbnail';
                            const url = URL.createObjectURL(file);
                            createdObjectUrls.push(url);
                            img.src = url;
                            rowDiv.appendChild(img);

                            const promise = new Promise((resolve) => {
                                img.onload = () => {
                                    img.dataset.originalWidth = img.width;
                                    img.dataset.originalHeight = img.height;
                                    resolve();
                                };
                                img.onerror = (err) => {
                                    console.error(`Image failed to load:`, err);
                                    resolve();
                                };
                            });
                            allImageLoadPromises.push(promise);
                        });
                    }
                }

                if (canvasElements.length > 1) { // More than just the header
                    canvases.set(canvasId, { id: canvasId, name: subfolder, elements: canvasElements, path: subfolder });
                }
            }

            await Promise.all(allImageLoadPromises);

            if (canvases.size > 0) {
                populateCanvasDropdown();
                renderCanvas(canvases.keys().next().value);
            } else {
                populateCanvasDropdown(); // Clears it
                thumbnailContainer.innerHTML = '<p style="color: black;">No matching thumbnails found for the shortcuts listed in scdata.txt.</p>';
            }
        }

        function generateDeleteScript() {
            let scriptLines = [
                '$PSScriptRoot = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition',
                `$scFolder = Join-Path -Path $PSScriptRoot -ChildPath 'sc'`,
                ''
            ];

            shortcutSelections.forEach((shortcutName, key) => {
                const escapedShortcutName = escapePSString(shortcutName);
                scriptLines.push(`$shortcutPath = Join-Path -Path $scFolder -ChildPath '${escapedShortcutName}'`);
                scriptLines.push('if (Test-Path -LiteralPath $shortcutPath) {');
                scriptLines.push('    Remove-Item -Path $shortcutPath');
                scriptLines.push(`    Write-Host "Deleted: ${escapedShortcutName}"`);
                scriptLines.push('} else {');
                scriptLines.push(`    Write-Host "Not found, skipped: ${escapedShortcutName}"`);
                scriptLines.push('}');
                scriptLines.push('');
            });

            scriptLines.push('Write-Host "Deletion script complete."');
            scriptLines.push('Read-Host -Prompt "Press Enter to exit"');

            const script = scriptLines.join('\r\n');
            batchScriptTextArea.value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
        }

        function parseRootScData(scdataText) {
            const lines = scdataText.split('\n').map(line => line.trim()).filter(line => line);
            const data = new Map();
            let currentSubfolder = null;

            for (let line of lines) {
                // In root scdata.txt, project headers are often quoted.
                const isProjectHeader = (line.startsWith('"') && line.endsWith('"')) || (line.startsWith("'") && line.endsWith("'"));
                const cleanLine = line.replace(/^["']|["']$/g, '').trim();
                
                // shortcuts in root scdata.txt (from scmanager.bat) might NOT have .lnk extension.
                // But they usually have a video extension.
                const isShortcut = cleanLine.toLowerCase().endsWith('.lnk') || cleanLine.toLowerCase().endsWith('.ink');
                const isVideo = cleanLine.toLowerCase().match(/\.(mp4|mkv|avi|mov|wmv|flv|webm|m4v|mpg|mpeg)$/i);

                if (isProjectHeader || (!isShortcut && !isVideo)) {
                    // It's a project name
                    currentSubfolder = normalizeProjectKey(cleanLine);
                    if (currentSubfolder && !data.has(currentSubfolder)) {
                        data.set(currentSubfolder, []);
                    }
                } else if (currentSubfolder && (isShortcut || isVideo)) {
                    data.get(currentSubfolder).push(cleanLine.toLowerCase());
                }
            }
            return data;
        }

        init();

    </script>
</body>
</html>
